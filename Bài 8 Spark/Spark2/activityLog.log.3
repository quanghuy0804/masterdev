14 Jul 2022 14:05:18,871 Executor task launch worker for task 773 - Task 773 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@636fce52
14 Jul 2022 14:05:18,871 Executor task launch worker for task 773 - Finished task 121.0 in stage 9.0 (TID 773). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,871 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,871 dispatcher-event-loop-1 - Starting task 122.0 in stage 9.0 (TID 774, localhost, executor driver, partition 122, ANY, 7756 bytes)
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Running task 122.0 in stage 9.0 (TID 774)
14 Jul 2022 14:05:18,871 task-result-getter-1 - Finished task 121.0 in stage 9.0 (TID 773) in 21 ms on localhost (executor driver) (168/200)
14 Jul 2022 14:05:18,871 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Fetching outputs for shuffle 5, partitions 122-123
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Start fetching local blocks: shuffle_5_0_122
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Task 774 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@59b3289b
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Task 774 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@59b3289b
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Task 774 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@59b3289b
14 Jul 2022 14:05:18,871 Executor task launch worker for task 774 - Task 774 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@59b3289b
14 Jul 2022 14:05:18,891 Executor task launch worker for task 774 - Finished task 122.0 in stage 9.0 (TID 774). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,892 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,892 dispatcher-event-loop-1 - Starting task 124.0 in stage 9.0 (TID 775, localhost, executor driver, partition 124, ANY, 7756 bytes)
14 Jul 2022 14:05:18,893 Executor task launch worker for task 775 - Running task 124.0 in stage 9.0 (TID 775)
14 Jul 2022 14:05:18,893 task-result-getter-2 - Finished task 122.0 in stage 9.0 (TID 774) in 22 ms on localhost (executor driver) (169/200)
14 Jul 2022 14:05:18,893 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - Fetching outputs for shuffle 5, partitions 124-125
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - Start fetching local blocks: shuffle_5_0_124
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,894 Executor task launch worker for task 775 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - Task 775 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@46b85c37
14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - Task 775 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@46b85c37
14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - Task 775 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@46b85c37
14 Jul 2022 14:05:18,897 Executor task launch worker for task 775 - Task 775 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@46b85c37
14 Jul 2022 14:05:18,908 Executor task launch worker for task 775 - Finished task 124.0 in stage 9.0 (TID 775). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,908 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,908 dispatcher-event-loop-1 - Starting task 125.0 in stage 9.0 (TID 776, localhost, executor driver, partition 125, ANY, 7756 bytes)
14 Jul 2022 14:05:18,908 Executor task launch worker for task 776 - Running task 125.0 in stage 9.0 (TID 776)
14 Jul 2022 14:05:18,909 task-result-getter-3 - Finished task 124.0 in stage 9.0 (TID 775) in 17 ms on localhost (executor driver) (170/200)
14 Jul 2022 14:05:18,909 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,910 Executor task launch worker for task 776 - Fetching outputs for shuffle 5, partitions 125-126
14 Jul 2022 14:05:18,910 Executor task launch worker for task 776 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,910 Executor task launch worker for task 776 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,910 Executor task launch worker for task 776 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,910 Executor task launch worker for task 776 - Start fetching local blocks: shuffle_5_0_125
14 Jul 2022 14:05:18,911 Executor task launch worker for task 776 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,912 Executor task launch worker for task 776 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,913 Executor task launch worker for task 776 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,913 Executor task launch worker for task 776 - Task 776 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@79860093
14 Jul 2022 14:05:18,914 Executor task launch worker for task 776 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,914 Executor task launch worker for task 776 - Task 776 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@79860093
14 Jul 2022 14:05:18,914 Executor task launch worker for task 776 - Task 776 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@79860093
14 Jul 2022 14:05:18,915 Executor task launch worker for task 776 - Task 776 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@79860093
14 Jul 2022 14:05:18,922 Executor task launch worker for task 776 - Finished task 125.0 in stage 9.0 (TID 776). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,922 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,922 dispatcher-event-loop-1 - Starting task 129.0 in stage 9.0 (TID 777, localhost, executor driver, partition 129, ANY, 7756 bytes)
14 Jul 2022 14:05:18,922 task-result-getter-0 - Finished task 125.0 in stage 9.0 (TID 776) in 14 ms on localhost (executor driver) (171/200)
14 Jul 2022 14:05:18,922 Executor task launch worker for task 777 - Running task 129.0 in stage 9.0 (TID 777)
14 Jul 2022 14:05:18,922 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Fetching outputs for shuffle 5, partitions 129-130
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Start fetching local blocks: shuffle_5_0_129
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Task 777 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2170de01
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Task 777 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2170de01
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Task 777 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2170de01
14 Jul 2022 14:05:18,926 Executor task launch worker for task 777 - Task 777 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2170de01
14 Jul 2022 14:05:18,936 Executor task launch worker for task 777 - Finished task 129.0 in stage 9.0 (TID 777). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,936 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,936 dispatcher-event-loop-1 - Starting task 131.0 in stage 9.0 (TID 778, localhost, executor driver, partition 131, ANY, 7756 bytes)
14 Jul 2022 14:05:18,936 Executor task launch worker for task 778 - Running task 131.0 in stage 9.0 (TID 778)
14 Jul 2022 14:05:18,936 task-result-getter-1 - Finished task 129.0 in stage 9.0 (TID 777) in 14 ms on localhost (executor driver) (172/200)
14 Jul 2022 14:05:18,936 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Fetching outputs for shuffle 5, partitions 131-132
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Start fetching local blocks: shuffle_5_0_131
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Task 778 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@50a4d370
14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,938 Executor task launch worker for task 778 - Task 778 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@50a4d370
14 Jul 2022 14:05:18,942 Executor task launch worker for task 778 - Task 778 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@50a4d370
14 Jul 2022 14:05:18,942 Executor task launch worker for task 778 - Task 778 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@50a4d370
14 Jul 2022 14:05:18,949 Executor task launch worker for task 778 - Finished task 131.0 in stage 9.0 (TID 778). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,949 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,949 dispatcher-event-loop-1 - Starting task 132.0 in stage 9.0 (TID 779, localhost, executor driver, partition 132, ANY, 7756 bytes)
14 Jul 2022 14:05:18,949 Executor task launch worker for task 779 - Running task 132.0 in stage 9.0 (TID 779)
14 Jul 2022 14:05:18,949 task-result-getter-2 - Finished task 131.0 in stage 9.0 (TID 778) in 13 ms on localhost (executor driver) (173/200)
14 Jul 2022 14:05:18,951 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,951 Executor task launch worker for task 779 - Fetching outputs for shuffle 5, partitions 132-133
14 Jul 2022 14:05:18,951 Executor task launch worker for task 779 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,951 Executor task launch worker for task 779 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,951 Executor task launch worker for task 779 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,951 Executor task launch worker for task 779 - Start fetching local blocks: shuffle_5_0_132
14 Jul 2022 14:05:18,953 Executor task launch worker for task 779 - Got local blocks in  2 ms
14 Jul 2022 14:05:18,954 Executor task launch worker for task 779 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,954 Executor task launch worker for task 779 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,954 Executor task launch worker for task 779 - Task 779 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1caef988
14 Jul 2022 14:05:18,955 Executor task launch worker for task 779 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,956 Executor task launch worker for task 779 - Task 779 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1caef988
14 Jul 2022 14:05:18,956 Executor task launch worker for task 779 - Task 779 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1caef988
14 Jul 2022 14:05:18,957 Executor task launch worker for task 779 - Task 779 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1caef988
14 Jul 2022 14:05:18,964 Executor task launch worker for task 779 - Finished task 132.0 in stage 9.0 (TID 779). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,964 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,965 dispatcher-event-loop-1 - Starting task 133.0 in stage 9.0 (TID 780, localhost, executor driver, partition 133, ANY, 7756 bytes)
14 Jul 2022 14:05:18,965 Executor task launch worker for task 780 - Running task 133.0 in stage 9.0 (TID 780)
14 Jul 2022 14:05:18,965 task-result-getter-3 - Finished task 132.0 in stage 9.0 (TID 779) in 16 ms on localhost (executor driver) (174/200)
14 Jul 2022 14:05:18,965 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,967 Executor task launch worker for task 780 - Fetching outputs for shuffle 5, partitions 133-134
14 Jul 2022 14:05:18,967 Executor task launch worker for task 780 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,967 Executor task launch worker for task 780 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,967 Executor task launch worker for task 780 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,967 Executor task launch worker for task 780 - Start fetching local blocks: shuffle_5_0_133
14 Jul 2022 14:05:18,968 Executor task launch worker for task 780 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - Task 780 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2bebbdea
14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - Task 780 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2bebbdea
14 Jul 2022 14:05:18,969 Executor task launch worker for task 780 - Task 780 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2bebbdea
14 Jul 2022 14:05:18,971 Executor task launch worker for task 780 - Task 780 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2bebbdea
14 Jul 2022 14:05:18,978 Executor task launch worker for task 780 - Finished task 133.0 in stage 9.0 (TID 780). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,979 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,979 dispatcher-event-loop-1 - Starting task 137.0 in stage 9.0 (TID 781, localhost, executor driver, partition 137, ANY, 7756 bytes)
14 Jul 2022 14:05:18,979 Executor task launch worker for task 781 - Running task 137.0 in stage 9.0 (TID 781)
14 Jul 2022 14:05:18,979 task-result-getter-0 - Finished task 133.0 in stage 9.0 (TID 780) in 14 ms on localhost (executor driver) (175/200)
14 Jul 2022 14:05:18,979 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,981 Executor task launch worker for task 781 - Fetching outputs for shuffle 5, partitions 137-138
14 Jul 2022 14:05:18,981 Executor task launch worker for task 781 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,981 Executor task launch worker for task 781 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,981 Executor task launch worker for task 781 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,981 Executor task launch worker for task 781 - Start fetching local blocks: shuffle_5_0_137
14 Jul 2022 14:05:18,982 Executor task launch worker for task 781 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,983 Executor task launch worker for task 781 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,983 Executor task launch worker for task 781 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,983 Executor task launch worker for task 781 - Task 781 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@72aaa9b8
14 Jul 2022 14:05:18,984 Executor task launch worker for task 781 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,984 Executor task launch worker for task 781 - Task 781 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@72aaa9b8
14 Jul 2022 14:05:18,984 Executor task launch worker for task 781 - Task 781 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@72aaa9b8
14 Jul 2022 14:05:18,986 Executor task launch worker for task 781 - Task 781 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@72aaa9b8
14 Jul 2022 14:05:18,995 Executor task launch worker for task 781 - Finished task 137.0 in stage 9.0 (TID 781). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,995 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,996 dispatcher-event-loop-1 - Starting task 139.0 in stage 9.0 (TID 782, localhost, executor driver, partition 139, ANY, 7756 bytes)
14 Jul 2022 14:05:18,996 Executor task launch worker for task 782 - Running task 139.0 in stage 9.0 (TID 782)
14 Jul 2022 14:05:18,996 task-result-getter-1 - Finished task 137.0 in stage 9.0 (TID 781) in 17 ms on localhost (executor driver) (176/200)
14 Jul 2022 14:05:18,996 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Fetching outputs for shuffle 5, partitions 139-140
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Start fetching local blocks: shuffle_5_0_139
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Task 782 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@60175277
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Task 782 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@60175277
14 Jul 2022 14:05:18,998 Executor task launch worker for task 782 - Task 782 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@60175277
14 Jul 2022 14:05:19,001 Executor task launch worker for task 782 - Task 782 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@60175277
14 Jul 2022 14:05:19,007 Executor task launch worker for task 782 - Finished task 139.0 in stage 9.0 (TID 782). 3003 bytes result sent to driver
14 Jul 2022 14:05:19,007 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,007 dispatcher-event-loop-1 - Starting task 140.0 in stage 9.0 (TID 783, localhost, executor driver, partition 140, ANY, 7756 bytes)
14 Jul 2022 14:05:19,008 Executor task launch worker for task 783 - Running task 140.0 in stage 9.0 (TID 783)
14 Jul 2022 14:05:19,008 task-result-getter-2 - Finished task 139.0 in stage 9.0 (TID 782) in 13 ms on localhost (executor driver) (177/200)
14 Jul 2022 14:05:19,008 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - Fetching outputs for shuffle 5, partitions 140-141
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - Start fetching local blocks: shuffle_5_0_140
14 Jul 2022 14:05:19,009 Executor task launch worker for task 783 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - Task 783 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@148f5383
14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - Task 783 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@148f5383
14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - Task 783 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@148f5383
14 Jul 2022 14:05:19,011 Executor task launch worker for task 783 - Task 783 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@148f5383
14 Jul 2022 14:05:19,017 Executor task launch worker for task 783 - Finished task 140.0 in stage 9.0 (TID 783). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,017 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,017 dispatcher-event-loop-1 - Starting task 141.0 in stage 9.0 (TID 784, localhost, executor driver, partition 141, ANY, 7756 bytes)
14 Jul 2022 14:05:19,017 Executor task launch worker for task 784 - Running task 141.0 in stage 9.0 (TID 784)
14 Jul 2022 14:05:19,017 task-result-getter-3 - Finished task 140.0 in stage 9.0 (TID 783) in 10 ms on localhost (executor driver) (178/200)
14 Jul 2022 14:05:19,019 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - Fetching outputs for shuffle 5, partitions 141-142
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - Start fetching local blocks: shuffle_5_0_141
14 Jul 2022 14:05:19,020 Executor task launch worker for task 784 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,022 Executor task launch worker for task 784 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,023 Executor task launch worker for task 784 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,023 Executor task launch worker for task 784 - Task 784 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5bf20647
14 Jul 2022 14:05:19,023 Executor task launch worker for task 784 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,024 Executor task launch worker for task 784 - Task 784 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5bf20647
14 Jul 2022 14:05:19,025 Executor task launch worker for task 784 - Task 784 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5bf20647
14 Jul 2022 14:05:19,026 Executor task launch worker for task 784 - Task 784 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5bf20647
14 Jul 2022 14:05:19,031 Executor task launch worker for task 784 - Finished task 141.0 in stage 9.0 (TID 784). 3003 bytes result sent to driver
14 Jul 2022 14:05:19,031 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,031 dispatcher-event-loop-1 - Starting task 142.0 in stage 9.0 (TID 785, localhost, executor driver, partition 142, ANY, 7756 bytes)
14 Jul 2022 14:05:19,031 Executor task launch worker for task 785 - Running task 142.0 in stage 9.0 (TID 785)
14 Jul 2022 14:05:19,031 task-result-getter-0 - Finished task 141.0 in stage 9.0 (TID 784) in 14 ms on localhost (executor driver) (179/200)
14 Jul 2022 14:05:19,031 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,033 Executor task launch worker for task 785 - Fetching outputs for shuffle 5, partitions 142-143
14 Jul 2022 14:05:19,033 Executor task launch worker for task 785 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,033 Executor task launch worker for task 785 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,033 Executor task launch worker for task 785 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,033 Executor task launch worker for task 785 - Start fetching local blocks: shuffle_5_0_142
14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - Got local blocks in  1 ms
14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - Task 785 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@190cf504
14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - Task 785 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@190cf504
14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - Task 785 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@190cf504
14 Jul 2022 14:05:19,034 Executor task launch worker for task 785 - Task 785 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@190cf504
14 Jul 2022 14:05:19,043 Executor task launch worker for task 785 - Finished task 142.0 in stage 9.0 (TID 785). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,043 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,043 dispatcher-event-loop-1 - Starting task 145.0 in stage 9.0 (TID 786, localhost, executor driver, partition 145, ANY, 7756 bytes)
14 Jul 2022 14:05:19,043 Executor task launch worker for task 786 - Running task 145.0 in stage 9.0 (TID 786)
14 Jul 2022 14:05:19,043 task-result-getter-1 - Finished task 142.0 in stage 9.0 (TID 785) in 12 ms on localhost (executor driver) (180/200)
14 Jul 2022 14:05:19,044 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,044 Executor task launch worker for task 786 - Fetching outputs for shuffle 5, partitions 145-146
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Start fetching local blocks: shuffle_5_0_145
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Task 786 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2ddcef92
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Task 786 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2ddcef92
14 Jul 2022 14:05:19,045 Executor task launch worker for task 786 - Task 786 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2ddcef92
14 Jul 2022 14:05:19,049 Executor task launch worker for task 786 - Task 786 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2ddcef92
14 Jul 2022 14:05:19,054 Executor task launch worker for task 786 - Finished task 145.0 in stage 9.0 (TID 786). 3003 bytes result sent to driver
14 Jul 2022 14:05:19,054 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,054 dispatcher-event-loop-1 - Starting task 146.0 in stage 9.0 (TID 787, localhost, executor driver, partition 146, ANY, 7756 bytes)
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Running task 146.0 in stage 9.0 (TID 787)
14 Jul 2022 14:05:19,055 task-result-getter-2 - Finished task 145.0 in stage 9.0 (TID 786) in 12 ms on localhost (executor driver) (181/200)
14 Jul 2022 14:05:19,055 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Fetching outputs for shuffle 5, partitions 146-147
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Start fetching local blocks: shuffle_5_0_146
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Task 787 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@4e51d722
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Task 787 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@4e51d722
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Task 787 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@4e51d722
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Task 787 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@4e51d722
14 Jul 2022 14:05:19,055 Executor task launch worker for task 787 - Finished task 146.0 in stage 9.0 (TID 787). 2874 bytes result sent to driver
14 Jul 2022 14:05:19,055 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,055 dispatcher-event-loop-1 - Starting task 148.0 in stage 9.0 (TID 788, localhost, executor driver, partition 148, ANY, 7756 bytes)
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Running task 148.0 in stage 9.0 (TID 788)
14 Jul 2022 14:05:19,055 task-result-getter-3 - Finished task 146.0 in stage 9.0 (TID 787) in 1 ms on localhost (executor driver) (182/200)
14 Jul 2022 14:05:19,055 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Fetching outputs for shuffle 5, partitions 148-149
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Start fetching local blocks: shuffle_5_0_148
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Task 788 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@7b60d52b
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Task 788 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@7b60d52b
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Task 788 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@7b60d52b
14 Jul 2022 14:05:19,055 Executor task launch worker for task 788 - Task 788 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@7b60d52b
14 Jul 2022 14:05:19,075 Executor task launch worker for task 788 - Finished task 148.0 in stage 9.0 (TID 788). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,076 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,076 dispatcher-event-loop-1 - Starting task 149.0 in stage 9.0 (TID 789, localhost, executor driver, partition 149, ANY, 7756 bytes)
14 Jul 2022 14:05:19,076 Executor task launch worker for task 789 - Running task 149.0 in stage 9.0 (TID 789)
14 Jul 2022 14:05:19,076 task-result-getter-0 - Finished task 148.0 in stage 9.0 (TID 788) in 21 ms on localhost (executor driver) (183/200)
14 Jul 2022 14:05:19,076 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Fetching outputs for shuffle 5, partitions 149-150
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Start fetching local blocks: shuffle_5_0_149
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Task 789 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@79bbc3d0
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Task 789 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@79bbc3d0
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Task 789 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@79bbc3d0
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Task 789 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@79bbc3d0
14 Jul 2022 14:05:19,077 Executor task launch worker for task 789 - Finished task 149.0 in stage 9.0 (TID 789). 2917 bytes result sent to driver
14 Jul 2022 14:05:19,077 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,077 dispatcher-event-loop-1 - Starting task 153.0 in stage 9.0 (TID 790, localhost, executor driver, partition 153, ANY, 7756 bytes)
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Running task 153.0 in stage 9.0 (TID 790)
14 Jul 2022 14:05:19,077 task-result-getter-1 - Finished task 149.0 in stage 9.0 (TID 789) in 1 ms on localhost (executor driver) (184/200)
14 Jul 2022 14:05:19,077 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Fetching outputs for shuffle 5, partitions 153-154
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Start fetching local blocks: shuffle_5_0_153
14 Jul 2022 14:05:19,077 Executor task launch worker for task 790 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,092 Executor task launch worker for task 790 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - Task 790 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@ddb7046
14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - Task 790 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@ddb7046
14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - Task 790 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@ddb7046
14 Jul 2022 14:05:19,093 Executor task launch worker for task 790 - Task 790 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@ddb7046
14 Jul 2022 14:05:19,097 Executor task launch worker for task 790 - Finished task 153.0 in stage 9.0 (TID 790). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,097 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,097 dispatcher-event-loop-1 - Starting task 156.0 in stage 9.0 (TID 791, localhost, executor driver, partition 156, ANY, 7756 bytes)
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Running task 156.0 in stage 9.0 (TID 791)
14 Jul 2022 14:05:19,097 task-result-getter-2 - Finished task 153.0 in stage 9.0 (TID 790) in 20 ms on localhost (executor driver) (185/200)
14 Jul 2022 14:05:19,097 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Fetching outputs for shuffle 5, partitions 156-157
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Start fetching local blocks: shuffle_5_0_156
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Task 791 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1da07438
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Task 791 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1da07438
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Task 791 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1da07438
14 Jul 2022 14:05:19,097 Executor task launch worker for task 791 - Task 791 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1da07438
14 Jul 2022 14:05:19,111 Executor task launch worker for task 791 - Finished task 156.0 in stage 9.0 (TID 791). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,111 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,111 dispatcher-event-loop-1 - Starting task 160.0 in stage 9.0 (TID 792, localhost, executor driver, partition 160, ANY, 7756 bytes)
14 Jul 2022 14:05:19,111 Executor task launch worker for task 792 - Running task 160.0 in stage 9.0 (TID 792)
14 Jul 2022 14:05:19,111 task-result-getter-3 - Finished task 156.0 in stage 9.0 (TID 791) in 14 ms on localhost (executor driver) (186/200)
14 Jul 2022 14:05:19,112 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Fetching outputs for shuffle 5, partitions 160-161
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Start fetching local blocks: shuffle_5_0_160
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Task 792 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@47ea75b2
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Task 792 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@47ea75b2
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Task 792 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@47ea75b2
14 Jul 2022 14:05:19,112 Executor task launch worker for task 792 - Task 792 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@47ea75b2
14 Jul 2022 14:05:19,120 Executor task launch worker for task 792 - Finished task 160.0 in stage 9.0 (TID 792). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,120 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,120 dispatcher-event-loop-1 - Starting task 162.0 in stage 9.0 (TID 793, localhost, executor driver, partition 162, ANY, 7756 bytes)
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Running task 162.0 in stage 9.0 (TID 793)
14 Jul 2022 14:05:19,120 task-result-getter-0 - Finished task 160.0 in stage 9.0 (TID 792) in 9 ms on localhost (executor driver) (187/200)
14 Jul 2022 14:05:19,120 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Fetching outputs for shuffle 5, partitions 162-163
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Start fetching local blocks: shuffle_5_0_162
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Task 793 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@47d041b8
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Task 793 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@47d041b8
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Task 793 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@47d041b8
14 Jul 2022 14:05:19,120 Executor task launch worker for task 793 - Task 793 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@47d041b8
14 Jul 2022 14:05:19,131 Executor task launch worker for task 793 - Finished task 162.0 in stage 9.0 (TID 793). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,132 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,132 dispatcher-event-loop-1 - Starting task 163.0 in stage 9.0 (TID 794, localhost, executor driver, partition 163, ANY, 7756 bytes)
14 Jul 2022 14:05:19,132 Executor task launch worker for task 794 - Running task 163.0 in stage 9.0 (TID 794)
14 Jul 2022 14:05:19,132 task-result-getter-1 - Finished task 162.0 in stage 9.0 (TID 793) in 12 ms on localhost (executor driver) (188/200)
14 Jul 2022 14:05:19,132 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,133 Executor task launch worker for task 794 - Fetching outputs for shuffle 5, partitions 163-164
14 Jul 2022 14:05:19,134 Executor task launch worker for task 794 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,134 Executor task launch worker for task 794 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,134 Executor task launch worker for task 794 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,134 Executor task launch worker for task 794 - Start fetching local blocks: shuffle_5_0_163
14 Jul 2022 14:05:19,134 Executor task launch worker for task 794 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,135 Executor task launch worker for task 794 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,135 Executor task launch worker for task 794 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,136 Executor task launch worker for task 794 - Task 794 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6ff01881
14 Jul 2022 14:05:19,136 Executor task launch worker for task 794 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,136 Executor task launch worker for task 794 - Task 794 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6ff01881
14 Jul 2022 14:05:19,137 Executor task launch worker for task 794 - Task 794 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6ff01881
14 Jul 2022 14:05:19,137 Executor task launch worker for task 794 - Task 794 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6ff01881
14 Jul 2022 14:05:19,144 Executor task launch worker for task 794 - Finished task 163.0 in stage 9.0 (TID 794). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,144 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,144 dispatcher-event-loop-1 - Starting task 165.0 in stage 9.0 (TID 795, localhost, executor driver, partition 165, ANY, 7756 bytes)
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Running task 165.0 in stage 9.0 (TID 795)
14 Jul 2022 14:05:19,144 task-result-getter-2 - Finished task 163.0 in stage 9.0 (TID 794) in 12 ms on localhost (executor driver) (189/200)
14 Jul 2022 14:05:19,144 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Fetching outputs for shuffle 5, partitions 165-166
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Start fetching local blocks: shuffle_5_0_165
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Task 795 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@42e44ad7
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Task 795 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@42e44ad7
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Task 795 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@42e44ad7
14 Jul 2022 14:05:19,144 Executor task launch worker for task 795 - Task 795 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@42e44ad7
14 Jul 2022 14:05:19,154 Executor task launch worker for task 795 - Finished task 165.0 in stage 9.0 (TID 795). 2917 bytes result sent to driver
14 Jul 2022 14:05:19,154 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,154 dispatcher-event-loop-1 - Starting task 170.0 in stage 9.0 (TID 796, localhost, executor driver, partition 170, ANY, 7756 bytes)
14 Jul 2022 14:05:19,155 Executor task launch worker for task 796 - Running task 170.0 in stage 9.0 (TID 796)
14 Jul 2022 14:05:19,155 task-result-getter-3 - Finished task 165.0 in stage 9.0 (TID 795) in 11 ms on localhost (executor driver) (190/200)
14 Jul 2022 14:05:19,155 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,156 Executor task launch worker for task 796 - Fetching outputs for shuffle 5, partitions 170-171
14 Jul 2022 14:05:19,156 Executor task launch worker for task 796 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,156 Executor task launch worker for task 796 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,156 Executor task launch worker for task 796 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,156 Executor task launch worker for task 796 - Start fetching local blocks: shuffle_5_0_170
14 Jul 2022 14:05:19,157 Executor task launch worker for task 796 - Got local blocks in  1 ms
14 Jul 2022 14:05:19,157 Executor task launch worker for task 796 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,158 Executor task launch worker for task 796 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,158 Executor task launch worker for task 796 - Task 796 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2fe11f99
14 Jul 2022 14:05:19,159 Executor task launch worker for task 796 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,159 Executor task launch worker for task 796 - Task 796 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2fe11f99
14 Jul 2022 14:05:19,159 Executor task launch worker for task 796 - Task 796 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2fe11f99
14 Jul 2022 14:05:19,160 Executor task launch worker for task 796 - Task 796 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2fe11f99
14 Jul 2022 14:05:19,165 Executor task launch worker for task 796 - Finished task 170.0 in stage 9.0 (TID 796). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,165 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,165 dispatcher-event-loop-1 - Starting task 177.0 in stage 9.0 (TID 797, localhost, executor driver, partition 177, ANY, 7756 bytes)
14 Jul 2022 14:05:19,165 Executor task launch worker for task 797 - Running task 177.0 in stage 9.0 (TID 797)
14 Jul 2022 14:05:19,166 task-result-getter-0 - Finished task 170.0 in stage 9.0 (TID 796) in 11 ms on localhost (executor driver) (191/200)
14 Jul 2022 14:05:19,166 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,167 Executor task launch worker for task 797 - Fetching outputs for shuffle 5, partitions 177-178
14 Jul 2022 14:05:19,167 Executor task launch worker for task 797 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,167 Executor task launch worker for task 797 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,167 Executor task launch worker for task 797 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,167 Executor task launch worker for task 797 - Start fetching local blocks: shuffle_5_0_177
14 Jul 2022 14:05:19,168 Executor task launch worker for task 797 - Got local blocks in  1 ms
14 Jul 2022 14:05:19,168 Executor task launch worker for task 797 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,169 Executor task launch worker for task 797 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,169 Executor task launch worker for task 797 - Task 797 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2671d998
14 Jul 2022 14:05:19,169 Executor task launch worker for task 797 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,169 Executor task launch worker for task 797 - Task 797 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2671d998
14 Jul 2022 14:05:19,170 Executor task launch worker for task 797 - Task 797 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2671d998
14 Jul 2022 14:05:19,170 Executor task launch worker for task 797 - Task 797 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2671d998
14 Jul 2022 14:05:19,175 Executor task launch worker for task 797 - Finished task 177.0 in stage 9.0 (TID 797). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,176 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,176 dispatcher-event-loop-1 - Starting task 178.0 in stage 9.0 (TID 798, localhost, executor driver, partition 178, ANY, 7756 bytes)
14 Jul 2022 14:05:19,176 Executor task launch worker for task 798 - Running task 178.0 in stage 9.0 (TID 798)
14 Jul 2022 14:05:19,176 task-result-getter-1 - Finished task 177.0 in stage 9.0 (TID 797) in 11 ms on localhost (executor driver) (192/200)
14 Jul 2022 14:05:19,176 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,177 Executor task launch worker for task 798 - Fetching outputs for shuffle 5, partitions 178-179
14 Jul 2022 14:05:19,177 Executor task launch worker for task 798 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,177 Executor task launch worker for task 798 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,177 Executor task launch worker for task 798 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,177 Executor task launch worker for task 798 - Start fetching local blocks: shuffle_5_0_178
14 Jul 2022 14:05:19,178 Executor task launch worker for task 798 - Got local blocks in  1 ms
14 Jul 2022 14:05:19,178 Executor task launch worker for task 798 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,178 Executor task launch worker for task 798 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,178 Executor task launch worker for task 798 - Task 798 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@36b0f0cd
14 Jul 2022 14:05:19,179 Executor task launch worker for task 798 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,179 Executor task launch worker for task 798 - Task 798 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@36b0f0cd
14 Jul 2022 14:05:19,179 Executor task launch worker for task 798 - Task 798 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@36b0f0cd
14 Jul 2022 14:05:19,180 Executor task launch worker for task 798 - Task 798 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@36b0f0cd
14 Jul 2022 14:05:19,185 Executor task launch worker for task 798 - Finished task 178.0 in stage 9.0 (TID 798). 3003 bytes result sent to driver
14 Jul 2022 14:05:19,185 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,185 dispatcher-event-loop-1 - Starting task 181.0 in stage 9.0 (TID 799, localhost, executor driver, partition 181, ANY, 7756 bytes)
14 Jul 2022 14:05:19,185 Executor task launch worker for task 799 - Running task 181.0 in stage 9.0 (TID 799)
14 Jul 2022 14:05:19,185 task-result-getter-2 - Finished task 178.0 in stage 9.0 (TID 798) in 9 ms on localhost (executor driver) (193/200)
14 Jul 2022 14:05:19,185 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,187 Executor task launch worker for task 799 - Fetching outputs for shuffle 5, partitions 181-182
14 Jul 2022 14:05:19,187 Executor task launch worker for task 799 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,187 Executor task launch worker for task 799 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,187 Executor task launch worker for task 799 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,187 Executor task launch worker for task 799 - Start fetching local blocks: shuffle_5_0_181
14 Jul 2022 14:05:19,188 Executor task launch worker for task 799 - Got local blocks in  1 ms
14 Jul 2022 14:05:19,189 Executor task launch worker for task 799 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,189 Executor task launch worker for task 799 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,190 Executor task launch worker for task 799 - Task 799 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1456319a
14 Jul 2022 14:05:19,190 Executor task launch worker for task 799 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,191 Executor task launch worker for task 799 - Task 799 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1456319a
14 Jul 2022 14:05:19,191 Executor task launch worker for task 799 - Task 799 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1456319a
14 Jul 2022 14:05:19,192 Executor task launch worker for task 799 - Task 799 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1456319a
14 Jul 2022 14:05:19,197 Executor task launch worker for task 799 - Finished task 181.0 in stage 9.0 (TID 799). 2960 bytes result sent to driver
14 Jul 2022 14:05:19,197 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,197 dispatcher-event-loop-1 - Starting task 182.0 in stage 9.0 (TID 800, localhost, executor driver, partition 182, ANY, 7756 bytes)
14 Jul 2022 14:05:19,197 Executor task launch worker for task 800 - Running task 182.0 in stage 9.0 (TID 800)
14 Jul 2022 14:05:19,197 task-result-getter-3 - Finished task 181.0 in stage 9.0 (TID 799) in 12 ms on localhost (executor driver) (194/200)
14 Jul 2022 14:05:19,198 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - Fetching outputs for shuffle 5, partitions 182-183
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - Start fetching local blocks: shuffle_5_0_182
14 Jul 2022 14:05:19,199 Executor task launch worker for task 800 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,200 Executor task launch worker for task 800 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,200 Executor task launch worker for task 800 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,200 Executor task launch worker for task 800 - Task 800 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5ff6c4aa
14 Jul 2022 14:05:19,201 Executor task launch worker for task 800 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:19,201 Executor task launch worker for task 800 - Task 800 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5ff6c4aa
14 Jul 2022 14:05:19,201 Executor task launch worker for task 800 - Task 800 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5ff6c4aa
14 Jul 2022 14:05:19,202 Executor task launch worker for task 800 - Task 800 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5ff6c4aa
14 Jul 2022 14:05:19,212 Executor task launch worker for task 800 - Finished task 182.0 in stage 9.0 (TID 800). 2917 bytes result sent to driver
14 Jul 2022 14:05:19,212 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:19,212 dispatcher-event-loop-1 - Starting task 183.0 in stage 9.0 (TID 801, localhost, executor driver, partition 183, ANY, 7756 bytes)
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Running task 183.0 in stage 9.0 (TID 801)
14 Jul 2022 14:05:19,212 task-result-getter-0 - Finished task 182.0 in stage 9.0 (TID 800) in 15 ms on localhost (executor driver) (195/200)
14 Jul 2022 14:05:19,212 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Fetching outputs for shuffle 5, partitions 183-184
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Start fetching local blocks: shuffle_5_0_183
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Got local blocks in  0 ms
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - Task 801 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@25d5862e
14 Jul 2022 14:05:19,212 Executor task launch worker for task 801 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

