14 Jul 2022 14:05:18,028 Executor task launch worker for task 717 - Finished task 9.0 in stage 9.0 (TID 717). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,028 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,028 dispatcher-event-loop-1 - Starting task 15.0 in stage 9.0 (TID 718, localhost, executor driver, partition 15, ANY, 7756 bytes)
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Running task 15.0 in stage 9.0 (TID 718)
14 Jul 2022 14:05:18,028 task-result-getter-1 - Finished task 9.0 in stage 9.0 (TID 717) in 12 ms on localhost (executor driver) (112/200)
14 Jul 2022 14:05:18,028 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Fetching outputs for shuffle 5, partitions 15-16
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Start fetching local blocks: shuffle_5_0_15
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Task 718 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2768e574
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Task 718 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2768e574
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Task 718 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2768e574
14 Jul 2022 14:05:18,028 Executor task launch worker for task 718 - Task 718 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2768e574
14 Jul 2022 14:05:18,041 Executor task launch worker for task 718 - Finished task 15.0 in stage 9.0 (TID 718). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,041 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,041 dispatcher-event-loop-1 - Starting task 17.0 in stage 9.0 (TID 719, localhost, executor driver, partition 17, ANY, 7756 bytes)
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Running task 17.0 in stage 9.0 (TID 719)
14 Jul 2022 14:05:18,041 task-result-getter-2 - Finished task 15.0 in stage 9.0 (TID 718) in 13 ms on localhost (executor driver) (113/200)
14 Jul 2022 14:05:18,041 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Fetching outputs for shuffle 5, partitions 17-18
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Start fetching local blocks: shuffle_5_0_17
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Task 719 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@f60d37e
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Task 719 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@f60d37e
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Task 719 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@f60d37e
14 Jul 2022 14:05:18,041 Executor task launch worker for task 719 - Task 719 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@f60d37e
14 Jul 2022 14:05:18,057 Executor task launch worker for task 719 - Finished task 17.0 in stage 9.0 (TID 719). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,057 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,057 dispatcher-event-loop-1 - Starting task 23.0 in stage 9.0 (TID 720, localhost, executor driver, partition 23, ANY, 7756 bytes)
14 Jul 2022 14:05:18,057 Executor task launch worker for task 720 - Running task 23.0 in stage 9.0 (TID 720)
14 Jul 2022 14:05:18,057 task-result-getter-3 - Finished task 17.0 in stage 9.0 (TID 719) in 16 ms on localhost (executor driver) (114/200)
14 Jul 2022 14:05:18,057 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,058 Executor task launch worker for task 720 - Fetching outputs for shuffle 5, partitions 23-24
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Start fetching local blocks: shuffle_5_0_23
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Task 720 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@4209efbd
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Task 720 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@4209efbd
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Task 720 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@4209efbd
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Task 720 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@4209efbd
14 Jul 2022 14:05:18,060 Executor task launch worker for task 720 - Finished task 23.0 in stage 9.0 (TID 720). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,060 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,060 dispatcher-event-loop-1 - Starting task 24.0 in stage 9.0 (TID 721, localhost, executor driver, partition 24, ANY, 7756 bytes)
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Running task 24.0 in stage 9.0 (TID 721)
14 Jul 2022 14:05:18,060 task-result-getter-0 - Finished task 23.0 in stage 9.0 (TID 720) in 3 ms on localhost (executor driver) (115/200)
14 Jul 2022 14:05:18,060 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Fetching outputs for shuffle 5, partitions 24-25
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Start fetching local blocks: shuffle_5_0_24
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Task 721 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@7db164d4
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Task 721 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@7db164d4
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Task 721 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@7db164d4
14 Jul 2022 14:05:18,060 Executor task launch worker for task 721 - Task 721 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@7db164d4
14 Jul 2022 14:05:18,088 Executor task launch worker for task 721 - Finished task 24.0 in stage 9.0 (TID 721). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,088 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,088 dispatcher-event-loop-1 - Starting task 25.0 in stage 9.0 (TID 722, localhost, executor driver, partition 25, ANY, 7756 bytes)
14 Jul 2022 14:05:18,088 Executor task launch worker for task 722 - Running task 25.0 in stage 9.0 (TID 722)
14 Jul 2022 14:05:18,088 task-result-getter-1 - Finished task 24.0 in stage 9.0 (TID 721) in 28 ms on localhost (executor driver) (116/200)
14 Jul 2022 14:05:18,088 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - Fetching outputs for shuffle 5, partitions 25-26
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - Start fetching local blocks: shuffle_5_0_25
14 Jul 2022 14:05:18,089 Executor task launch worker for task 722 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,092 Executor task launch worker for task 722 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,093 Executor task launch worker for task 722 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,093 Executor task launch worker for task 722 - Task 722 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1297f3ee
14 Jul 2022 14:05:18,094 Executor task launch worker for task 722 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,094 Executor task launch worker for task 722 - Task 722 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1297f3ee
14 Jul 2022 14:05:18,094 Executor task launch worker for task 722 - Task 722 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1297f3ee
14 Jul 2022 14:05:18,095 Executor task launch worker for task 722 - Task 722 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1297f3ee
14 Jul 2022 14:05:18,111 Executor task launch worker for task 722 - Finished task 25.0 in stage 9.0 (TID 722). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,112 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,112 dispatcher-event-loop-1 - Starting task 26.0 in stage 9.0 (TID 723, localhost, executor driver, partition 26, ANY, 7756 bytes)
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - Running task 26.0 in stage 9.0 (TID 723)
14 Jul 2022 14:05:18,112 task-result-getter-2 - Finished task 25.0 in stage 9.0 (TID 722) in 24 ms on localhost (executor driver) (117/200)
14 Jul 2022 14:05:18,112 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - Fetching outputs for shuffle 5, partitions 26-27
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,112 Executor task launch worker for task 723 - Start fetching local blocks: shuffle_5_0_26
14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - Got local blocks in  2 ms
14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - Task 723 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6204f2a2
14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - Task 723 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6204f2a2
14 Jul 2022 14:05:18,114 Executor task launch worker for task 723 - Task 723 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6204f2a2
14 Jul 2022 14:05:18,118 Executor task launch worker for task 723 - Task 723 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6204f2a2
14 Jul 2022 14:05:18,127 Executor task launch worker for task 723 - Finished task 26.0 in stage 9.0 (TID 723). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,127 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,127 dispatcher-event-loop-1 - Starting task 27.0 in stage 9.0 (TID 724, localhost, executor driver, partition 27, ANY, 7756 bytes)
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Running task 27.0 in stage 9.0 (TID 724)
14 Jul 2022 14:05:18,127 task-result-getter-3 - Finished task 26.0 in stage 9.0 (TID 723) in 15 ms on localhost (executor driver) (118/200)
14 Jul 2022 14:05:18,127 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Fetching outputs for shuffle 5, partitions 27-28
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Start fetching local blocks: shuffle_5_0_27
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Task 724 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@62a3320a
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Task 724 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@62a3320a
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Task 724 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@62a3320a
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Task 724 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@62a3320a
14 Jul 2022 14:05:18,127 Executor task launch worker for task 724 - Finished task 27.0 in stage 9.0 (TID 724). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,127 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,127 dispatcher-event-loop-1 - Starting task 28.0 in stage 9.0 (TID 725, localhost, executor driver, partition 28, ANY, 7756 bytes)
14 Jul 2022 14:05:18,127 Executor task launch worker for task 725 - Running task 28.0 in stage 9.0 (TID 725)
14 Jul 2022 14:05:18,127 task-result-getter-0 - Finished task 27.0 in stage 9.0 (TID 724) in 0 ms on localhost (executor driver) (119/200)
14 Jul 2022 14:05:18,127 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Fetching outputs for shuffle 5, partitions 28-29
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Start fetching local blocks: shuffle_5_0_28
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Task 725 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@dfd2bc4
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Task 725 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@dfd2bc4
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Task 725 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@dfd2bc4
14 Jul 2022 14:05:18,140 Executor task launch worker for task 725 - Task 725 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@dfd2bc4
14 Jul 2022 14:05:18,148 Executor task launch worker for task 725 - Finished task 28.0 in stage 9.0 (TID 725). 3046 bytes result sent to driver
14 Jul 2022 14:05:18,148 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,148 dispatcher-event-loop-1 - Starting task 30.0 in stage 9.0 (TID 726, localhost, executor driver, partition 30, ANY, 7756 bytes)
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Running task 30.0 in stage 9.0 (TID 726)
14 Jul 2022 14:05:18,148 task-result-getter-1 - Finished task 28.0 in stage 9.0 (TID 725) in 21 ms on localhost (executor driver) (120/200)
14 Jul 2022 14:05:18,148 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Fetching outputs for shuffle 5, partitions 30-31
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Start fetching local blocks: shuffle_5_0_30
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Task 726 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1f25e07e
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Task 726 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1f25e07e
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Task 726 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1f25e07e
14 Jul 2022 14:05:18,148 Executor task launch worker for task 726 - Task 726 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1f25e07e
14 Jul 2022 14:05:18,158 Executor task launch worker for task 726 - Finished task 30.0 in stage 9.0 (TID 726). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,158 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,158 dispatcher-event-loop-1 - Starting task 31.0 in stage 9.0 (TID 727, localhost, executor driver, partition 31, ANY, 7756 bytes)
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Running task 31.0 in stage 9.0 (TID 727)
14 Jul 2022 14:05:18,158 task-result-getter-2 - Finished task 30.0 in stage 9.0 (TID 726) in 10 ms on localhost (executor driver) (121/200)
14 Jul 2022 14:05:18,158 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Fetching outputs for shuffle 5, partitions 31-32
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Start fetching local blocks: shuffle_5_0_31
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Task 727 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6a2cd3e0
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Task 727 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6a2cd3e0
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Task 727 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6a2cd3e0
14 Jul 2022 14:05:18,158 Executor task launch worker for task 727 - Task 727 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6a2cd3e0
14 Jul 2022 14:05:18,169 Executor task launch worker for task 727 - Finished task 31.0 in stage 9.0 (TID 727). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,169 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,169 dispatcher-event-loop-1 - Starting task 32.0 in stage 9.0 (TID 728, localhost, executor driver, partition 32, ANY, 7756 bytes)
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Running task 32.0 in stage 9.0 (TID 728)
14 Jul 2022 14:05:18,169 task-result-getter-3 - Finished task 31.0 in stage 9.0 (TID 727) in 11 ms on localhost (executor driver) (122/200)
14 Jul 2022 14:05:18,169 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Fetching outputs for shuffle 5, partitions 32-33
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Start fetching local blocks: shuffle_5_0_32
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Task 728 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5db42dae
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Task 728 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5db42dae
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Task 728 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5db42dae
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Task 728 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5db42dae
14 Jul 2022 14:05:18,169 Executor task launch worker for task 728 - Finished task 32.0 in stage 9.0 (TID 728). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,169 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,169 dispatcher-event-loop-1 - Starting task 33.0 in stage 9.0 (TID 729, localhost, executor driver, partition 33, ANY, 7756 bytes)
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Running task 33.0 in stage 9.0 (TID 729)
14 Jul 2022 14:05:18,169 task-result-getter-0 - Finished task 32.0 in stage 9.0 (TID 728) in 0 ms on localhost (executor driver) (123/200)
14 Jul 2022 14:05:18,169 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Fetching outputs for shuffle 5, partitions 33-34
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Start fetching local blocks: shuffle_5_0_33
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - Task 729 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@694e39fc
14 Jul 2022 14:05:18,169 Executor task launch worker for task 729 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,185 Executor task launch worker for task 729 - Task 729 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@694e39fc
14 Jul 2022 14:05:18,185 Executor task launch worker for task 729 - Task 729 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@694e39fc
14 Jul 2022 14:05:18,185 Executor task launch worker for task 729 - Task 729 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@694e39fc
14 Jul 2022 14:05:18,193 Executor task launch worker for task 729 - Finished task 33.0 in stage 9.0 (TID 729). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,193 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,193 dispatcher-event-loop-1 - Starting task 38.0 in stage 9.0 (TID 730, localhost, executor driver, partition 38, ANY, 7756 bytes)
14 Jul 2022 14:05:18,193 Executor task launch worker for task 730 - Running task 38.0 in stage 9.0 (TID 730)
14 Jul 2022 14:05:18,193 task-result-getter-1 - Finished task 33.0 in stage 9.0 (TID 729) in 24 ms on localhost (executor driver) (124/200)
14 Jul 2022 14:05:18,194 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - Fetching outputs for shuffle 5, partitions 38-39
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - Start fetching local blocks: shuffle_5_0_38
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,194 Executor task launch worker for task 730 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - Task 730 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1704d6f5
14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - Task 730 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1704d6f5
14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - Task 730 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1704d6f5
14 Jul 2022 14:05:18,197 Executor task launch worker for task 730 - Task 730 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1704d6f5
14 Jul 2022 14:05:18,203 Executor task launch worker for task 730 - Finished task 38.0 in stage 9.0 (TID 730). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,203 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,203 dispatcher-event-loop-1 - Starting task 39.0 in stage 9.0 (TID 731, localhost, executor driver, partition 39, ANY, 7756 bytes)
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Running task 39.0 in stage 9.0 (TID 731)
14 Jul 2022 14:05:18,203 task-result-getter-2 - Finished task 38.0 in stage 9.0 (TID 730) in 10 ms on localhost (executor driver) (125/200)
14 Jul 2022 14:05:18,203 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Fetching outputs for shuffle 5, partitions 39-40
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Start fetching local blocks: shuffle_5_0_39
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Task 731 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@13b65b19
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Task 731 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@13b65b19
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Task 731 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@13b65b19
14 Jul 2022 14:05:18,203 Executor task launch worker for task 731 - Task 731 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@13b65b19
14 Jul 2022 14:05:18,228 Executor task launch worker for task 731 - Finished task 39.0 in stage 9.0 (TID 731). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,228 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,228 dispatcher-event-loop-1 - Starting task 41.0 in stage 9.0 (TID 732, localhost, executor driver, partition 41, ANY, 7756 bytes)
14 Jul 2022 14:05:18,228 Executor task launch worker for task 732 - Running task 41.0 in stage 9.0 (TID 732)
14 Jul 2022 14:05:18,228 task-result-getter-3 - Finished task 39.0 in stage 9.0 (TID 731) in 25 ms on localhost (executor driver) (126/200)
14 Jul 2022 14:05:18,230 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Fetching outputs for shuffle 5, partitions 41-42
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Start fetching local blocks: shuffle_5_0_41
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Task 732 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5b40b920
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Task 732 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5b40b920
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Task 732 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5b40b920
14 Jul 2022 14:05:18,231 Executor task launch worker for task 732 - Task 732 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5b40b920
14 Jul 2022 14:05:18,241 Executor task launch worker for task 732 - Finished task 41.0 in stage 9.0 (TID 732). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,242 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,242 dispatcher-event-loop-1 - Starting task 42.0 in stage 9.0 (TID 733, localhost, executor driver, partition 42, ANY, 7756 bytes)
14 Jul 2022 14:05:18,242 Executor task launch worker for task 733 - Running task 42.0 in stage 9.0 (TID 733)
14 Jul 2022 14:05:18,242 task-result-getter-0 - Finished task 41.0 in stage 9.0 (TID 732) in 14 ms on localhost (executor driver) (127/200)
14 Jul 2022 14:05:18,242 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,244 Executor task launch worker for task 733 - Fetching outputs for shuffle 5, partitions 42-43
14 Jul 2022 14:05:18,244 Executor task launch worker for task 733 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,244 Executor task launch worker for task 733 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,244 Executor task launch worker for task 733 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,244 Executor task launch worker for task 733 - Start fetching local blocks: shuffle_5_0_42
14 Jul 2022 14:05:18,245 Executor task launch worker for task 733 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,246 Executor task launch worker for task 733 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,246 Executor task launch worker for task 733 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,246 Executor task launch worker for task 733 - Task 733 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@15470f89
14 Jul 2022 14:05:18,246 Executor task launch worker for task 733 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,261 Executor task launch worker for task 733 - Task 733 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@15470f89
14 Jul 2022 14:05:18,261 Executor task launch worker for task 733 - Task 733 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@15470f89
14 Jul 2022 14:05:18,292 Executor task launch worker for task 733 - Task 733 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@15470f89
14 Jul 2022 14:05:18,298 Executor task launch worker for task 733 - Finished task 42.0 in stage 9.0 (TID 733). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,298 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,298 dispatcher-event-loop-1 - Starting task 45.0 in stage 9.0 (TID 734, localhost, executor driver, partition 45, ANY, 7756 bytes)
14 Jul 2022 14:05:18,298 Executor task launch worker for task 734 - Running task 45.0 in stage 9.0 (TID 734)
14 Jul 2022 14:05:18,298 task-result-getter-1 - Finished task 42.0 in stage 9.0 (TID 733) in 56 ms on localhost (executor driver) (128/200)
14 Jul 2022 14:05:18,301 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - Fetching outputs for shuffle 5, partitions 45-46
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - Start fetching local blocks: shuffle_5_0_45
14 Jul 2022 14:05:18,303 Executor task launch worker for task 734 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,304 Executor task launch worker for task 734 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,304 Executor task launch worker for task 734 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,304 Executor task launch worker for task 734 - Task 734 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@44054edc
14 Jul 2022 14:05:18,305 Executor task launch worker for task 734 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,305 Executor task launch worker for task 734 - Task 734 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@44054edc
14 Jul 2022 14:05:18,305 Executor task launch worker for task 734 - Task 734 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@44054edc
14 Jul 2022 14:05:18,306 Executor task launch worker for task 734 - Task 734 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@44054edc
14 Jul 2022 14:05:18,310 Executor task launch worker for task 734 - Finished task 45.0 in stage 9.0 (TID 734). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,310 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,310 dispatcher-event-loop-1 - Starting task 48.0 in stage 9.0 (TID 735, localhost, executor driver, partition 48, ANY, 7756 bytes)
14 Jul 2022 14:05:18,310 Executor task launch worker for task 735 - Running task 48.0 in stage 9.0 (TID 735)
14 Jul 2022 14:05:18,310 task-result-getter-2 - Finished task 45.0 in stage 9.0 (TID 734) in 12 ms on localhost (executor driver) (129/200)
14 Jul 2022 14:05:18,310 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,315 Executor task launch worker for task 735 - Fetching outputs for shuffle 5, partitions 48-49
14 Jul 2022 14:05:18,315 Executor task launch worker for task 735 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,315 Executor task launch worker for task 735 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,315 Executor task launch worker for task 735 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,315 Executor task launch worker for task 735 - Start fetching local blocks: shuffle_5_0_48
14 Jul 2022 14:05:18,316 Executor task launch worker for task 735 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,316 Executor task launch worker for task 735 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,316 Executor task launch worker for task 735 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,316 Executor task launch worker for task 735 - Task 735 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6f25a228
14 Jul 2022 14:05:18,318 Executor task launch worker for task 735 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,319 Executor task launch worker for task 735 - Task 735 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6f25a228
14 Jul 2022 14:05:18,319 Executor task launch worker for task 735 - Task 735 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6f25a228
14 Jul 2022 14:05:18,320 Executor task launch worker for task 735 - Task 735 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6f25a228
14 Jul 2022 14:05:18,328 Executor task launch worker for task 735 - Finished task 48.0 in stage 9.0 (TID 735). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,328 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,328 dispatcher-event-loop-1 - Starting task 55.0 in stage 9.0 (TID 736, localhost, executor driver, partition 55, ANY, 7756 bytes)
14 Jul 2022 14:05:18,328 Executor task launch worker for task 736 - Running task 55.0 in stage 9.0 (TID 736)
14 Jul 2022 14:05:18,328 task-result-getter-3 - Finished task 48.0 in stage 9.0 (TID 735) in 18 ms on localhost (executor driver) (130/200)
14 Jul 2022 14:05:18,328 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,332 Executor task launch worker for task 736 - Fetching outputs for shuffle 5, partitions 55-56
14 Jul 2022 14:05:18,332 Executor task launch worker for task 736 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,332 Executor task launch worker for task 736 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,332 Executor task launch worker for task 736 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,332 Executor task launch worker for task 736 - Start fetching local blocks: shuffle_5_0_55
14 Jul 2022 14:05:18,333 Executor task launch worker for task 736 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,334 Executor task launch worker for task 736 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,334 Executor task launch worker for task 736 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,334 Executor task launch worker for task 736 - Task 736 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1425cc90
14 Jul 2022 14:05:18,335 Executor task launch worker for task 736 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,335 Executor task launch worker for task 736 - Task 736 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1425cc90
14 Jul 2022 14:05:18,335 Executor task launch worker for task 736 - Task 736 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1425cc90
14 Jul 2022 14:05:18,336 Executor task launch worker for task 736 - Task 736 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1425cc90
14 Jul 2022 14:05:18,341 Executor task launch worker for task 736 - Finished task 55.0 in stage 9.0 (TID 736). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,341 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,342 dispatcher-event-loop-1 - Starting task 57.0 in stage 9.0 (TID 737, localhost, executor driver, partition 57, ANY, 7756 bytes)
14 Jul 2022 14:05:18,342 Executor task launch worker for task 737 - Running task 57.0 in stage 9.0 (TID 737)
14 Jul 2022 14:05:18,342 task-result-getter-0 - Finished task 55.0 in stage 9.0 (TID 736) in 14 ms on localhost (executor driver) (131/200)
14 Jul 2022 14:05:18,343 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Fetching outputs for shuffle 5, partitions 57-58
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Start fetching local blocks: shuffle_5_0_57
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Task 737 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2e552169
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Task 737 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2e552169
14 Jul 2022 14:05:18,343 Executor task launch worker for task 737 - Task 737 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2e552169
14 Jul 2022 14:05:18,348 Executor task launch worker for task 737 - Task 737 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2e552169
14 Jul 2022 14:05:18,355 Executor task launch worker for task 737 - Finished task 57.0 in stage 9.0 (TID 737). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,355 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,355 dispatcher-event-loop-1 - Starting task 61.0 in stage 9.0 (TID 738, localhost, executor driver, partition 61, ANY, 7756 bytes)
14 Jul 2022 14:05:18,355 Executor task launch worker for task 738 - Running task 61.0 in stage 9.0 (TID 738)
14 Jul 2022 14:05:18,355 task-result-getter-1 - Finished task 57.0 in stage 9.0 (TID 737) in 14 ms on localhost (executor driver) (132/200)
14 Jul 2022 14:05:18,355 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - Fetching outputs for shuffle 5, partitions 61-62
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - Start fetching local blocks: shuffle_5_0_61
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,357 Executor task launch worker for task 738 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,360 Executor task launch worker for task 738 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,360 Executor task launch worker for task 738 - Task 738 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@686ad20e
14 Jul 2022 14:05:18,360 Executor task launch worker for task 738 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,361 Executor task launch worker for task 738 - Task 738 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@686ad20e
14 Jul 2022 14:05:18,361 Executor task launch worker for task 738 - Task 738 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@686ad20e
14 Jul 2022 14:05:18,362 Executor task launch worker for task 738 - Task 738 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@686ad20e
14 Jul 2022 14:05:18,369 Executor task launch worker for task 738 - Finished task 61.0 in stage 9.0 (TID 738). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,369 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,369 dispatcher-event-loop-1 - Starting task 62.0 in stage 9.0 (TID 739, localhost, executor driver, partition 62, ANY, 7756 bytes)
14 Jul 2022 14:05:18,369 Executor task launch worker for task 739 - Running task 62.0 in stage 9.0 (TID 739)
14 Jul 2022 14:05:18,369 task-result-getter-2 - Finished task 61.0 in stage 9.0 (TID 738) in 14 ms on localhost (executor driver) (133/200)
14 Jul 2022 14:05:18,369 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Fetching outputs for shuffle 5, partitions 62-63
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Start fetching local blocks: shuffle_5_0_62
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Task 739 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6531da66
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Task 739 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6531da66
14 Jul 2022 14:05:18,370 Executor task launch worker for task 739 - Task 739 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6531da66
14 Jul 2022 14:05:18,376 Executor task launch worker for task 739 - Task 739 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6531da66
14 Jul 2022 14:05:18,382 Executor task launch worker for task 739 - Finished task 62.0 in stage 9.0 (TID 739). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,382 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,382 dispatcher-event-loop-1 - Starting task 64.0 in stage 9.0 (TID 740, localhost, executor driver, partition 64, ANY, 7756 bytes)
14 Jul 2022 14:05:18,382 Executor task launch worker for task 740 - Running task 64.0 in stage 9.0 (TID 740)
14 Jul 2022 14:05:18,382 task-result-getter-3 - Finished task 62.0 in stage 9.0 (TID 739) in 13 ms on localhost (executor driver) (134/200)
14 Jul 2022 14:05:18,383 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Fetching outputs for shuffle 5, partitions 64-65
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Start fetching local blocks: shuffle_5_0_64
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Task 740 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@24fd243a
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Task 740 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@24fd243a
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Task 740 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@24fd243a
14 Jul 2022 14:05:18,383 Executor task launch worker for task 740 - Task 740 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@24fd243a
14 Jul 2022 14:05:18,394 Executor task launch worker for task 740 - Finished task 64.0 in stage 9.0 (TID 740). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,394 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,394 dispatcher-event-loop-1 - Starting task 65.0 in stage 9.0 (TID 741, localhost, executor driver, partition 65, ANY, 7756 bytes)
14 Jul 2022 14:05:18,394 Executor task launch worker for task 741 - Running task 65.0 in stage 9.0 (TID 741)
14 Jul 2022 14:05:18,394 task-result-getter-0 - Finished task 64.0 in stage 9.0 (TID 740) in 12 ms on localhost (executor driver) (135/200)
14 Jul 2022 14:05:18,395 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,397 Executor task launch worker for task 741 - Fetching outputs for shuffle 5, partitions 65-66
14 Jul 2022 14:05:18,397 Executor task launch worker for task 741 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,397 Executor task launch worker for task 741 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,397 Executor task launch worker for task 741 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,397 Executor task launch worker for task 741 - Start fetching local blocks: shuffle_5_0_65
14 Jul 2022 14:05:18,399 Executor task launch worker for task 741 - Got local blocks in  2 ms
14 Jul 2022 14:05:18,399 Executor task launch worker for task 741 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,400 Executor task launch worker for task 741 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,400 Executor task launch worker for task 741 - Task 741 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@4b958722
14 Jul 2022 14:05:18,400 Executor task launch worker for task 741 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,401 Executor task launch worker for task 741 - Task 741 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@4b958722
14 Jul 2022 14:05:18,401 Executor task launch worker for task 741 - Task 741 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@4b958722
14 Jul 2022 14:05:18,402 Executor task launch worker for task 741 - Task 741 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@4b958722
14 Jul 2022 14:05:18,408 Executor task launch worker for task 741 - Finished task 65.0 in stage 9.0 (TID 741). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,409 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,409 dispatcher-event-loop-1 - Starting task 66.0 in stage 9.0 (TID 742, localhost, executor driver, partition 66, ANY, 7756 bytes)
14 Jul 2022 14:05:18,409 Executor task launch worker for task 742 - Running task 66.0 in stage 9.0 (TID 742)
14 Jul 2022 14:05:18,409 task-result-getter-1 - Finished task 65.0 in stage 9.0 (TID 741) in 15 ms on localhost (executor driver) (136/200)
14 Jul 2022 14:05:18,410 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,410 Executor task launch worker for task 742 - Fetching outputs for shuffle 5, partitions 66-67
14 Jul 2022 14:05:18,410 Executor task launch worker for task 742 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,410 Executor task launch worker for task 742 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,410 Executor task launch worker for task 742 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,410 Executor task launch worker for task 742 - Start fetching local blocks: shuffle_5_0_66
14 Jul 2022 14:05:18,412 Executor task launch worker for task 742 - Got local blocks in  2 ms
14 Jul 2022 14:05:18,413 Executor task launch worker for task 742 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,413 Executor task launch worker for task 742 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,413 Executor task launch worker for task 742 - Task 742 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6104550a
14 Jul 2022 14:05:18,414 Executor task launch worker for task 742 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,415 Executor task launch worker for task 742 - Task 742 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6104550a
14 Jul 2022 14:05:18,415 Executor task launch worker for task 742 - Task 742 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6104550a
14 Jul 2022 14:05:18,416 Executor task launch worker for task 742 - Task 742 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6104550a
14 Jul 2022 14:05:18,481 Executor task launch worker for task 742 - Finished task 66.0 in stage 9.0 (TID 742). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,481 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,482 dispatcher-event-loop-1 - Starting task 70.0 in stage 9.0 (TID 743, localhost, executor driver, partition 70, ANY, 7756 bytes)
14 Jul 2022 14:05:18,482 Executor task launch worker for task 743 - Running task 70.0 in stage 9.0 (TID 743)
14 Jul 2022 14:05:18,482 task-result-getter-2 - Finished task 66.0 in stage 9.0 (TID 742) in 73 ms on localhost (executor driver) (137/200)
14 Jul 2022 14:05:18,482 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,484 Executor task launch worker for task 743 - Fetching outputs for shuffle 5, partitions 70-71
14 Jul 2022 14:05:18,484 Executor task launch worker for task 743 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,485 Executor task launch worker for task 743 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,485 Executor task launch worker for task 743 - Started 0 remote fetches in 1 ms
14 Jul 2022 14:05:18,485 Executor task launch worker for task 743 - Start fetching local blocks: shuffle_5_0_70
14 Jul 2022 14:05:18,485 Executor task launch worker for task 743 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,485 Executor task launch worker for task 743 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,486 Executor task launch worker for task 743 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,487 Executor task launch worker for task 743 - Task 743 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@53f12c89
14 Jul 2022 14:05:18,487 Executor task launch worker for task 743 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,488 Executor task launch worker for task 743 - Task 743 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@53f12c89
14 Jul 2022 14:05:18,489 Executor task launch worker for task 743 - Task 743 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@53f12c89
14 Jul 2022 14:05:18,490 Executor task launch worker for task 743 - Task 743 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@53f12c89
14 Jul 2022 14:05:18,514 Executor task launch worker for task 743 - Finished task 70.0 in stage 9.0 (TID 743). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,514 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,514 dispatcher-event-loop-1 - Starting task 73.0 in stage 9.0 (TID 744, localhost, executor driver, partition 73, ANY, 7756 bytes)
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Running task 73.0 in stage 9.0 (TID 744)
14 Jul 2022 14:05:18,514 task-result-getter-3 - Finished task 70.0 in stage 9.0 (TID 743) in 32 ms on localhost (executor driver) (138/200)
14 Jul 2022 14:05:18,514 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Fetching outputs for shuffle 5, partitions 73-74
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Start fetching local blocks: shuffle_5_0_73
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Task 744 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2e5163a0
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Task 744 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2e5163a0
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Task 744 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2e5163a0
14 Jul 2022 14:05:18,514 Executor task launch worker for task 744 - Task 744 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2e5163a0
14 Jul 2022 14:05:18,531 Executor task launch worker for task 744 - Finished task 73.0 in stage 9.0 (TID 744). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,531 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,532 dispatcher-event-loop-1 - Starting task 75.0 in stage 9.0 (TID 745, localhost, executor driver, partition 75, ANY, 7756 bytes)
14 Jul 2022 14:05:18,532 Executor task launch worker for task 745 - Running task 75.0 in stage 9.0 (TID 745)
14 Jul 2022 14:05:18,532 task-result-getter-0 - Finished task 73.0 in stage 9.0 (TID 744) in 18 ms on localhost (executor driver) (139/200)
14 Jul 2022 14:05:18,532 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,533 Executor task launch worker for task 745 - Fetching outputs for shuffle 5, partitions 75-76
14 Jul 2022 14:05:18,533 Executor task launch worker for task 745 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,533 Executor task launch worker for task 745 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,534 Executor task launch worker for task 745 - Started 0 remote fetches in 1 ms
14 Jul 2022 14:05:18,534 Executor task launch worker for task 745 - Start fetching local blocks: shuffle_5_0_75
14 Jul 2022 14:05:18,534 Executor task launch worker for task 745 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,535 Executor task launch worker for task 745 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,536 Executor task launch worker for task 745 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,536 Executor task launch worker for task 745 - Task 745 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@605ce9d5
14 Jul 2022 14:05:18,536 Executor task launch worker for task 745 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,536 Executor task launch worker for task 745 - Task 745 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@605ce9d5
14 Jul 2022 14:05:18,536 Executor task launch worker for task 745 - Task 745 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@605ce9d5
14 Jul 2022 14:05:18,538 Executor task launch worker for task 745 - Task 745 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@605ce9d5
