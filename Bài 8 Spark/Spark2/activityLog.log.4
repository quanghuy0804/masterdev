14 Jul 2022 14:05:18,547 Executor task launch worker for task 745 - Finished task 75.0 in stage 9.0 (TID 745). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,547 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,547 dispatcher-event-loop-1 - Starting task 76.0 in stage 9.0 (TID 746, localhost, executor driver, partition 76, ANY, 7756 bytes)
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Running task 76.0 in stage 9.0 (TID 746)
14 Jul 2022 14:05:18,547 task-result-getter-1 - Finished task 75.0 in stage 9.0 (TID 745) in 16 ms on localhost (executor driver) (140/200)
14 Jul 2022 14:05:18,547 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Fetching outputs for shuffle 5, partitions 76-77
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Start fetching local blocks: shuffle_5_0_76
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Task 746 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@3868749b
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Task 746 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@3868749b
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Task 746 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@3868749b
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Task 746 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@3868749b
14 Jul 2022 14:05:18,547 Executor task launch worker for task 746 - Finished task 76.0 in stage 9.0 (TID 746). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,547 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,547 dispatcher-event-loop-1 - Starting task 80.0 in stage 9.0 (TID 747, localhost, executor driver, partition 80, ANY, 7756 bytes)
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Running task 80.0 in stage 9.0 (TID 747)
14 Jul 2022 14:05:18,547 task-result-getter-2 - Finished task 76.0 in stage 9.0 (TID 746) in 0 ms on localhost (executor driver) (141/200)
14 Jul 2022 14:05:18,547 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Fetching outputs for shuffle 5, partitions 80-81
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Start fetching local blocks: shuffle_5_0_80
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - Task 747 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@301d10b8
14 Jul 2022 14:05:18,547 Executor task launch worker for task 747 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,563 Executor task launch worker for task 747 - Task 747 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@301d10b8
14 Jul 2022 14:05:18,563 Executor task launch worker for task 747 - Task 747 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@301d10b8
14 Jul 2022 14:05:18,563 Executor task launch worker for task 747 - Task 747 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@301d10b8
14 Jul 2022 14:05:18,568 Executor task launch worker for task 747 - Finished task 80.0 in stage 9.0 (TID 747). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,568 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,568 dispatcher-event-loop-1 - Starting task 81.0 in stage 9.0 (TID 748, localhost, executor driver, partition 81, ANY, 7756 bytes)
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Running task 81.0 in stage 9.0 (TID 748)
14 Jul 2022 14:05:18,568 task-result-getter-3 - Finished task 80.0 in stage 9.0 (TID 747) in 21 ms on localhost (executor driver) (142/200)
14 Jul 2022 14:05:18,568 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Fetching outputs for shuffle 5, partitions 81-82
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Start fetching local blocks: shuffle_5_0_81
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Task 748 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@7964fa11
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Task 748 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@7964fa11
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Task 748 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@7964fa11
14 Jul 2022 14:05:18,568 Executor task launch worker for task 748 - Task 748 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@7964fa11
14 Jul 2022 14:05:18,579 Executor task launch worker for task 748 - Finished task 81.0 in stage 9.0 (TID 748). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,579 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,580 dispatcher-event-loop-1 - Starting task 82.0 in stage 9.0 (TID 749, localhost, executor driver, partition 82, ANY, 7756 bytes)
14 Jul 2022 14:05:18,580 Executor task launch worker for task 749 - Running task 82.0 in stage 9.0 (TID 749)
14 Jul 2022 14:05:18,580 task-result-getter-0 - Finished task 81.0 in stage 9.0 (TID 748) in 12 ms on localhost (executor driver) (143/200)
14 Jul 2022 14:05:18,580 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,582 Executor task launch worker for task 749 - Fetching outputs for shuffle 5, partitions 82-83
14 Jul 2022 14:05:18,582 Executor task launch worker for task 749 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,582 Executor task launch worker for task 749 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,582 Executor task launch worker for task 749 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,582 Executor task launch worker for task 749 - Start fetching local blocks: shuffle_5_0_82
14 Jul 2022 14:05:18,583 Executor task launch worker for task 749 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,583 Executor task launch worker for task 749 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,583 Executor task launch worker for task 749 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,584 Executor task launch worker for task 749 - Task 749 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@68f8c8c7
14 Jul 2022 14:05:18,584 Executor task launch worker for task 749 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,585 Executor task launch worker for task 749 - Task 749 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@68f8c8c7
14 Jul 2022 14:05:18,585 Executor task launch worker for task 749 - Task 749 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@68f8c8c7
14 Jul 2022 14:05:18,585 Executor task launch worker for task 749 - Task 749 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@68f8c8c7
14 Jul 2022 14:05:18,590 Executor task launch worker for task 749 - Finished task 82.0 in stage 9.0 (TID 749). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,590 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,590 dispatcher-event-loop-1 - Starting task 84.0 in stage 9.0 (TID 750, localhost, executor driver, partition 84, ANY, 7756 bytes)
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Running task 84.0 in stage 9.0 (TID 750)
14 Jul 2022 14:05:18,590 task-result-getter-1 - Finished task 82.0 in stage 9.0 (TID 749) in 10 ms on localhost (executor driver) (144/200)
14 Jul 2022 14:05:18,590 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Fetching outputs for shuffle 5, partitions 84-85
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Start fetching local blocks: shuffle_5_0_84
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Task 750 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6f255ee3
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Task 750 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6f255ee3
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Task 750 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6f255ee3
14 Jul 2022 14:05:18,590 Executor task launch worker for task 750 - Task 750 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6f255ee3
14 Jul 2022 14:05:18,597 Executor task launch worker for task 750 - Finished task 84.0 in stage 9.0 (TID 750). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,597 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,597 dispatcher-event-loop-1 - Starting task 85.0 in stage 9.0 (TID 751, localhost, executor driver, partition 85, ANY, 7756 bytes)
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Running task 85.0 in stage 9.0 (TID 751)
14 Jul 2022 14:05:18,597 task-result-getter-2 - Finished task 84.0 in stage 9.0 (TID 750) in 7 ms on localhost (executor driver) (145/200)
14 Jul 2022 14:05:18,597 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Fetching outputs for shuffle 5, partitions 85-86
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Start fetching local blocks: shuffle_5_0_85
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Task 751 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@64d6d599
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Task 751 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@64d6d599
14 Jul 2022 14:05:18,597 Executor task launch worker for task 751 - Task 751 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@64d6d599
14 Jul 2022 14:05:18,606 Executor task launch worker for task 751 - Task 751 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@64d6d599
14 Jul 2022 14:05:18,609 Executor task launch worker for task 751 - Finished task 85.0 in stage 9.0 (TID 751). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,609 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,609 dispatcher-event-loop-1 - Starting task 86.0 in stage 9.0 (TID 752, localhost, executor driver, partition 86, ANY, 7756 bytes)
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Running task 86.0 in stage 9.0 (TID 752)
14 Jul 2022 14:05:18,609 task-result-getter-3 - Finished task 85.0 in stage 9.0 (TID 751) in 12 ms on localhost (executor driver) (146/200)
14 Jul 2022 14:05:18,609 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Fetching outputs for shuffle 5, partitions 86-87
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Start fetching local blocks: shuffle_5_0_86
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Task 752 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@2a905cb6
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Task 752 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@2a905cb6
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Task 752 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@2a905cb6
14 Jul 2022 14:05:18,609 Executor task launch worker for task 752 - Task 752 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@2a905cb6
14 Jul 2022 14:05:18,622 Executor task launch worker for task 752 - Finished task 86.0 in stage 9.0 (TID 752). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,622 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,623 dispatcher-event-loop-1 - Starting task 88.0 in stage 9.0 (TID 753, localhost, executor driver, partition 88, ANY, 7756 bytes)
14 Jul 2022 14:05:18,623 Executor task launch worker for task 753 - Running task 88.0 in stage 9.0 (TID 753)
14 Jul 2022 14:05:18,623 task-result-getter-0 - Finished task 86.0 in stage 9.0 (TID 752) in 14 ms on localhost (executor driver) (147/200)
14 Jul 2022 14:05:18,623 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Fetching outputs for shuffle 5, partitions 88-89
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Start fetching local blocks: shuffle_5_0_88
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Task 753 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@62f52036
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Task 753 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@62f52036
14 Jul 2022 14:05:18,625 Executor task launch worker for task 753 - Task 753 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@62f52036
14 Jul 2022 14:05:18,629 Executor task launch worker for task 753 - Task 753 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@62f52036
14 Jul 2022 14:05:18,644 Executor task launch worker for task 753 - Finished task 88.0 in stage 9.0 (TID 753). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,644 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,644 dispatcher-event-loop-1 - Starting task 90.0 in stage 9.0 (TID 754, localhost, executor driver, partition 90, ANY, 7756 bytes)
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Running task 90.0 in stage 9.0 (TID 754)
14 Jul 2022 14:05:18,644 task-result-getter-1 - Finished task 88.0 in stage 9.0 (TID 753) in 22 ms on localhost (executor driver) (148/200)
14 Jul 2022 14:05:18,644 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Fetching outputs for shuffle 5, partitions 90-91
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Start fetching local blocks: shuffle_5_0_90
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Task 754 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1ce3e8f6
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Task 754 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1ce3e8f6
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Task 754 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1ce3e8f6
14 Jul 2022 14:05:18,644 Executor task launch worker for task 754 - Task 754 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1ce3e8f6
14 Jul 2022 14:05:18,655 Executor task launch worker for task 754 - Finished task 90.0 in stage 9.0 (TID 754). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,655 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,655 dispatcher-event-loop-1 - Starting task 91.0 in stage 9.0 (TID 755, localhost, executor driver, partition 91, ANY, 7756 bytes)
14 Jul 2022 14:05:18,655 task-result-getter-2 - Finished task 90.0 in stage 9.0 (TID 754) in 11 ms on localhost (executor driver) (149/200)
14 Jul 2022 14:05:18,655 Executor task launch worker for task 755 - Running task 91.0 in stage 9.0 (TID 755)
14 Jul 2022 14:05:18,656 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,657 Executor task launch worker for task 755 - Fetching outputs for shuffle 5, partitions 91-92
14 Jul 2022 14:05:18,657 Executor task launch worker for task 755 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,657 Executor task launch worker for task 755 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,657 Executor task launch worker for task 755 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,657 Executor task launch worker for task 755 - Start fetching local blocks: shuffle_5_0_91
14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - Got local blocks in  2 ms
14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - Task 755 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@465dec1d
14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - Task 755 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@465dec1d
14 Jul 2022 14:05:18,659 Executor task launch worker for task 755 - Task 755 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@465dec1d
14 Jul 2022 14:05:18,662 Executor task launch worker for task 755 - Task 755 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@465dec1d
14 Jul 2022 14:05:18,680 Executor task launch worker for task 755 - Finished task 91.0 in stage 9.0 (TID 755). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,680 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,680 dispatcher-event-loop-1 - Starting task 93.0 in stage 9.0 (TID 756, localhost, executor driver, partition 93, ANY, 7756 bytes)
14 Jul 2022 14:05:18,680 task-result-getter-3 - Finished task 91.0 in stage 9.0 (TID 755) in 25 ms on localhost (executor driver) (150/200)
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Running task 93.0 in stage 9.0 (TID 756)
14 Jul 2022 14:05:18,680 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Fetching outputs for shuffle 5, partitions 93-94
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Start fetching local blocks: shuffle_5_0_93
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Task 756 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@571bedd7
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Task 756 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@571bedd7
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Task 756 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@571bedd7
14 Jul 2022 14:05:18,680 Executor task launch worker for task 756 - Task 756 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@571bedd7
14 Jul 2022 14:05:18,692 Executor task launch worker for task 756 - Finished task 93.0 in stage 9.0 (TID 756). 2917 bytes result sent to driver
14 Jul 2022 14:05:18,692 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,692 dispatcher-event-loop-1 - Starting task 94.0 in stage 9.0 (TID 757, localhost, executor driver, partition 94, ANY, 7756 bytes)
14 Jul 2022 14:05:18,692 Executor task launch worker for task 757 - Running task 94.0 in stage 9.0 (TID 757)
14 Jul 2022 14:05:18,693 task-result-getter-0 - Finished task 93.0 in stage 9.0 (TID 756) in 13 ms on localhost (executor driver) (151/200)
14 Jul 2022 14:05:18,693 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Fetching outputs for shuffle 5, partitions 94-95
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Start fetching local blocks: shuffle_5_0_94
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - Task 757 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@3d19c266
14 Jul 2022 14:05:18,693 Executor task launch worker for task 757 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,697 Executor task launch worker for task 757 - Task 757 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@3d19c266
14 Jul 2022 14:05:18,697 Executor task launch worker for task 757 - Task 757 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@3d19c266
14 Jul 2022 14:05:18,698 Executor task launch worker for task 757 - Task 757 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@3d19c266
14 Jul 2022 14:05:18,704 Executor task launch worker for task 757 - Finished task 94.0 in stage 9.0 (TID 757). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,704 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,705 dispatcher-event-loop-1 - Starting task 96.0 in stage 9.0 (TID 758, localhost, executor driver, partition 96, ANY, 7756 bytes)
14 Jul 2022 14:05:18,705 Executor task launch worker for task 758 - Running task 96.0 in stage 9.0 (TID 758)
14 Jul 2022 14:05:18,705 task-result-getter-1 - Finished task 94.0 in stage 9.0 (TID 757) in 13 ms on localhost (executor driver) (152/200)
14 Jul 2022 14:05:18,705 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,707 Executor task launch worker for task 758 - Fetching outputs for shuffle 5, partitions 96-97
14 Jul 2022 14:05:18,707 Executor task launch worker for task 758 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,707 Executor task launch worker for task 758 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,707 Executor task launch worker for task 758 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,707 Executor task launch worker for task 758 - Start fetching local blocks: shuffle_5_0_96
14 Jul 2022 14:05:18,708 Executor task launch worker for task 758 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,709 Executor task launch worker for task 758 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,709 Executor task launch worker for task 758 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,709 Executor task launch worker for task 758 - Task 758 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6ea9e601
14 Jul 2022 14:05:18,711 Executor task launch worker for task 758 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,711 Executor task launch worker for task 758 - Task 758 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6ea9e601
14 Jul 2022 14:05:18,711 Executor task launch worker for task 758 - Task 758 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6ea9e601
14 Jul 2022 14:05:18,712 Executor task launch worker for task 758 - Task 758 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6ea9e601
14 Jul 2022 14:05:18,717 Executor task launch worker for task 758 - Finished task 96.0 in stage 9.0 (TID 758). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,717 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,717 dispatcher-event-loop-1 - Starting task 99.0 in stage 9.0 (TID 759, localhost, executor driver, partition 99, ANY, 7756 bytes)
14 Jul 2022 14:05:18,718 Executor task launch worker for task 759 - Running task 99.0 in stage 9.0 (TID 759)
14 Jul 2022 14:05:18,718 task-result-getter-2 - Finished task 96.0 in stage 9.0 (TID 758) in 14 ms on localhost (executor driver) (153/200)
14 Jul 2022 14:05:18,718 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,719 Executor task launch worker for task 759 - Fetching outputs for shuffle 5, partitions 99-100
14 Jul 2022 14:05:18,719 Executor task launch worker for task 759 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,719 Executor task launch worker for task 759 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,719 Executor task launch worker for task 759 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,719 Executor task launch worker for task 759 - Start fetching local blocks: shuffle_5_0_99
14 Jul 2022 14:05:18,720 Executor task launch worker for task 759 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,720 Executor task launch worker for task 759 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,721 Executor task launch worker for task 759 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,721 Executor task launch worker for task 759 - Task 759 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@354a7a46
14 Jul 2022 14:05:18,721 Executor task launch worker for task 759 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,722 Executor task launch worker for task 759 - Task 759 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@354a7a46
14 Jul 2022 14:05:18,722 Executor task launch worker for task 759 - Task 759 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@354a7a46
14 Jul 2022 14:05:18,723 Executor task launch worker for task 759 - Task 759 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@354a7a46
14 Jul 2022 14:05:18,727 Executor task launch worker for task 759 - Finished task 99.0 in stage 9.0 (TID 759). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,727 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,727 dispatcher-event-loop-1 - Starting task 100.0 in stage 9.0 (TID 760, localhost, executor driver, partition 100, ANY, 7756 bytes)
14 Jul 2022 14:05:18,727 Executor task launch worker for task 760 - Running task 100.0 in stage 9.0 (TID 760)
14 Jul 2022 14:05:18,727 task-result-getter-3 - Finished task 99.0 in stage 9.0 (TID 759) in 10 ms on localhost (executor driver) (154/200)
14 Jul 2022 14:05:18,729 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Fetching outputs for shuffle 5, partitions 100-101
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Start fetching local blocks: shuffle_5_0_100
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Task 760 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@43f6c3aa
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Task 760 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@43f6c3aa
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Task 760 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@43f6c3aa
14 Jul 2022 14:05:18,729 Executor task launch worker for task 760 - Task 760 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@43f6c3aa
14 Jul 2022 14:05:18,740 Executor task launch worker for task 760 - Finished task 100.0 in stage 9.0 (TID 760). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,740 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,740 dispatcher-event-loop-1 - Starting task 102.0 in stage 9.0 (TID 761, localhost, executor driver, partition 102, ANY, 7756 bytes)
14 Jul 2022 14:05:18,740 Executor task launch worker for task 761 - Running task 102.0 in stage 9.0 (TID 761)
14 Jul 2022 14:05:18,740 task-result-getter-0 - Finished task 100.0 in stage 9.0 (TID 760) in 13 ms on localhost (executor driver) (155/200)
14 Jul 2022 14:05:18,740 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Fetching outputs for shuffle 5, partitions 102-103
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Start fetching local blocks: shuffle_5_0_102
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Task 761 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5b70c2af
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Task 761 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5b70c2af
14 Jul 2022 14:05:18,742 Executor task launch worker for task 761 - Task 761 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5b70c2af
14 Jul 2022 14:05:18,746 Executor task launch worker for task 761 - Task 761 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5b70c2af
14 Jul 2022 14:05:18,746 Executor task launch worker for task 761 - Finished task 102.0 in stage 9.0 (TID 761). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,746 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,746 dispatcher-event-loop-1 - Starting task 103.0 in stage 9.0 (TID 762, localhost, executor driver, partition 103, ANY, 7756 bytes)
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Running task 103.0 in stage 9.0 (TID 762)
14 Jul 2022 14:05:18,746 task-result-getter-1 - Finished task 102.0 in stage 9.0 (TID 761) in 6 ms on localhost (executor driver) (156/200)
14 Jul 2022 14:05:18,746 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Fetching outputs for shuffle 5, partitions 103-104
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Start fetching local blocks: shuffle_5_0_103
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Task 762 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6a9f6aee
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Task 762 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6a9f6aee
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Task 762 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6a9f6aee
14 Jul 2022 14:05:18,746 Executor task launch worker for task 762 - Task 762 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6a9f6aee
14 Jul 2022 14:05:18,759 Executor task launch worker for task 762 - Finished task 103.0 in stage 9.0 (TID 762). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,759 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,759 dispatcher-event-loop-1 - Starting task 104.0 in stage 9.0 (TID 763, localhost, executor driver, partition 104, ANY, 7756 bytes)
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Running task 104.0 in stage 9.0 (TID 763)
14 Jul 2022 14:05:18,759 task-result-getter-2 - Finished task 103.0 in stage 9.0 (TID 762) in 13 ms on localhost (executor driver) (157/200)
14 Jul 2022 14:05:18,759 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Fetching outputs for shuffle 5, partitions 104-105
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Start fetching local blocks: shuffle_5_0_104
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Task 763 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@67f6f22a
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Task 763 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@67f6f22a
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Task 763 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@67f6f22a
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Task 763 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@67f6f22a
14 Jul 2022 14:05:18,759 Executor task launch worker for task 763 - Finished task 104.0 in stage 9.0 (TID 763). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,759 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,759 dispatcher-event-loop-1 - Starting task 105.0 in stage 9.0 (TID 764, localhost, executor driver, partition 105, ANY, 7756 bytes)
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Running task 105.0 in stage 9.0 (TID 764)
14 Jul 2022 14:05:18,759 task-result-getter-3 - Finished task 104.0 in stage 9.0 (TID 763) in 0 ms on localhost (executor driver) (158/200)
14 Jul 2022 14:05:18,759 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Fetching outputs for shuffle 5, partitions 105-106
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Start fetching local blocks: shuffle_5_0_105
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Task 764 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@5cf64a6d
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Task 764 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@5cf64a6d
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Task 764 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@5cf64a6d
14 Jul 2022 14:05:18,759 Executor task launch worker for task 764 - Task 764 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@5cf64a6d
14 Jul 2022 14:05:18,775 Executor task launch worker for task 764 - Finished task 105.0 in stage 9.0 (TID 764). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,775 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,775 dispatcher-event-loop-1 - Starting task 106.0 in stage 9.0 (TID 765, localhost, executor driver, partition 106, ANY, 7756 bytes)
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Running task 106.0 in stage 9.0 (TID 765)
14 Jul 2022 14:05:18,775 task-result-getter-0 - Finished task 105.0 in stage 9.0 (TID 764) in 16 ms on localhost (executor driver) (159/200)
14 Jul 2022 14:05:18,775 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Fetching outputs for shuffle 5, partitions 106-107
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Start fetching local blocks: shuffle_5_0_106
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Task 765 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@1a2f621e
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Task 765 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@1a2f621e
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Task 765 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@1a2f621e
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Task 765 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@1a2f621e
14 Jul 2022 14:05:18,775 Executor task launch worker for task 765 - Finished task 106.0 in stage 9.0 (TID 765). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,775 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,775 dispatcher-event-loop-1 - Starting task 108.0 in stage 9.0 (TID 766, localhost, executor driver, partition 108, ANY, 7756 bytes)
14 Jul 2022 14:05:18,775 Executor task launch worker for task 766 - Running task 108.0 in stage 9.0 (TID 766)
14 Jul 2022 14:05:18,775 task-result-getter-1 - Finished task 106.0 in stage 9.0 (TID 765) in 0 ms on localhost (executor driver) (160/200)
14 Jul 2022 14:05:18,775 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,775 Executor task launch worker for task 766 - Fetching outputs for shuffle 5, partitions 108-109
14 Jul 2022 14:05:18,791 Executor task launch worker for task 766 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,791 Executor task launch worker for task 766 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Started 0 remote fetches in 1 ms
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Start fetching local blocks: shuffle_5_0_108
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Got local blocks in  1 ms
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Task 766 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@11659239
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Task 766 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@11659239
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Task 766 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@11659239
14 Jul 2022 14:05:18,792 Executor task launch worker for task 766 - Task 766 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@11659239
14 Jul 2022 14:05:18,798 Executor task launch worker for task 766 - Finished task 108.0 in stage 9.0 (TID 766). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,798 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,798 dispatcher-event-loop-1 - Starting task 110.0 in stage 9.0 (TID 767, localhost, executor driver, partition 110, ANY, 7756 bytes)
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Running task 110.0 in stage 9.0 (TID 767)
14 Jul 2022 14:05:18,798 task-result-getter-2 - Finished task 108.0 in stage 9.0 (TID 766) in 23 ms on localhost (executor driver) (161/200)
14 Jul 2022 14:05:18,798 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Fetching outputs for shuffle 5, partitions 110-111
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Start fetching local blocks: shuffle_5_0_110
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Task 767 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@295596c7
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Task 767 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@295596c7
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Task 767 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@295596c7
14 Jul 2022 14:05:18,798 Executor task launch worker for task 767 - Task 767 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@295596c7
14 Jul 2022 14:05:18,805 Executor task launch worker for task 767 - Finished task 110.0 in stage 9.0 (TID 767). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,805 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,805 dispatcher-event-loop-1 - Starting task 113.0 in stage 9.0 (TID 768, localhost, executor driver, partition 113, ANY, 7756 bytes)
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Running task 113.0 in stage 9.0 (TID 768)
14 Jul 2022 14:05:18,805 task-result-getter-3 - Finished task 110.0 in stage 9.0 (TID 767) in 7 ms on localhost (executor driver) (162/200)
14 Jul 2022 14:05:18,805 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Fetching outputs for shuffle 5, partitions 113-114
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Start fetching local blocks: shuffle_5_0_113
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Task 768 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@23d61bd8
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Task 768 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@23d61bd8
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Task 768 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@23d61bd8
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Task 768 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@23d61bd8
14 Jul 2022 14:05:18,805 Executor task launch worker for task 768 - Finished task 113.0 in stage 9.0 (TID 768). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,805 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,805 dispatcher-event-loop-1 - Starting task 114.0 in stage 9.0 (TID 769, localhost, executor driver, partition 114, ANY, 7756 bytes)
14 Jul 2022 14:05:18,805 Executor task launch worker for task 769 - Running task 114.0 in stage 9.0 (TID 769)
14 Jul 2022 14:05:18,805 task-result-getter-0 - Finished task 113.0 in stage 9.0 (TID 768) in 0 ms on localhost (executor driver) (163/200)
14 Jul 2022 14:05:18,821 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Fetching outputs for shuffle 5, partitions 114-115
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Start fetching local blocks: shuffle_5_0_114
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Task 769 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@4cfc3eae
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Task 769 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@4cfc3eae
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Task 769 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@4cfc3eae
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Task 769 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@4cfc3eae
14 Jul 2022 14:05:18,821 Executor task launch worker for task 769 - Finished task 114.0 in stage 9.0 (TID 769). 2960 bytes result sent to driver
14 Jul 2022 14:05:18,821 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,821 dispatcher-event-loop-1 - Starting task 116.0 in stage 9.0 (TID 770, localhost, executor driver, partition 116, ANY, 7756 bytes)
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Running task 116.0 in stage 9.0 (TID 770)
14 Jul 2022 14:05:18,821 task-result-getter-1 - Finished task 114.0 in stage 9.0 (TID 769) in 16 ms on localhost (executor driver) (164/200)
14 Jul 2022 14:05:18,821 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Fetching outputs for shuffle 5, partitions 116-117
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Start fetching local blocks: shuffle_5_0_116
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Task 770 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@6a6f4692
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Task 770 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@6a6f4692
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Task 770 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@6a6f4692
14 Jul 2022 14:05:18,821 Executor task launch worker for task 770 - Task 770 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@6a6f4692
14 Jul 2022 14:05:18,841 Executor task launch worker for task 770 - Finished task 116.0 in stage 9.0 (TID 770). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,841 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,841 dispatcher-event-loop-1 - Starting task 117.0 in stage 9.0 (TID 771, localhost, executor driver, partition 117, ANY, 7756 bytes)
14 Jul 2022 14:05:18,842 Executor task launch worker for task 771 - Running task 117.0 in stage 9.0 (TID 771)
14 Jul 2022 14:05:18,842 task-result-getter-2 - Finished task 116.0 in stage 9.0 (TID 770) in 21 ms on localhost (executor driver) (165/200)
14 Jul 2022 14:05:18,842 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Fetching outputs for shuffle 5, partitions 117-118
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Start fetching local blocks: shuffle_5_0_117
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Task 771 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@4aa397cf
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Task 771 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@4aa397cf
14 Jul 2022 14:05:18,844 Executor task launch worker for task 771 - Task 771 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@4aa397cf
14 Jul 2022 14:05:18,848 Executor task launch worker for task 771 - Task 771 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@4aa397cf
14 Jul 2022 14:05:18,850 Executor task launch worker for task 771 - Finished task 117.0 in stage 9.0 (TID 771). 3003 bytes result sent to driver
14 Jul 2022 14:05:18,850 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,850 dispatcher-event-loop-1 - Starting task 120.0 in stage 9.0 (TID 772, localhost, executor driver, partition 120, ANY, 7756 bytes)
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Running task 120.0 in stage 9.0 (TID 772)
14 Jul 2022 14:05:18,850 task-result-getter-3 - Finished task 117.0 in stage 9.0 (TID 771) in 9 ms on localhost (executor driver) (166/200)
14 Jul 2022 14:05:18,850 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Fetching outputs for shuffle 5, partitions 120-121
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Start fetching local blocks: shuffle_5_0_120
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Got local blocks in  0 ms
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Task 772 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@3f4b46e6
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Task 772 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@3f4b46e6
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Task 772 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@3f4b46e6
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Task 772 release 32.0 MB from org.apache.spark.unsafe.map.BytesToBytesMap@3f4b46e6
14 Jul 2022 14:05:18,850 Executor task launch worker for task 772 - Finished task 120.0 in stage 9.0 (TID 772). 2874 bytes result sent to driver
14 Jul 2022 14:05:18,850 dispatcher-event-loop-1 - parentName: , name: TaskSet_9.0, runningTasks: 0
14 Jul 2022 14:05:18,850 dispatcher-event-loop-1 - Starting task 121.0 in stage 9.0 (TID 773, localhost, executor driver, partition 121, ANY, 7756 bytes)
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - Running task 121.0 in stage 9.0 (TID 773)
14 Jul 2022 14:05:18,850 task-result-getter-0 - Finished task 120.0 in stage 9.0 (TID 772) in 0 ms on localhost (executor driver) (167/200)
14 Jul 2022 14:05:18,850 dag-scheduler-event-loop - ShuffleMapTask finished on driver
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - Fetching outputs for shuffle 5, partitions 121-122
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - maxBytesInFlight: 50331648, targetRequestSize: 10066329, maxBlocksInFlightPerAddress: 2147483647
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - Getting 1 non-empty blocks including 1 local blocks and 0 remote blocks
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - Started 0 remote fetches in 0 ms
14 Jul 2022 14:05:18,850 Executor task launch worker for task 773 - Start fetching local blocks: shuffle_5_0_121
14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - Got local blocks in  17 ms
14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - code for 0:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */
/* 030 */
/* 031 */
/* 032 */     mutableStateArray_0[0].write(0, 0L);
/* 033 */     return (mutableStateArray_0[0].getRow());
/* 034 */   }
/* 035 */
/* 036 */
/* 037 */ }

14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - code for input[0, string, true],input[1, string, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(2, 64);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     UTF8String value_0 = isNull_0 ?
/* 033 */     null : (i.getUTF8String(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */
/* 040 */     boolean isNull_1 = i.isNullAt(1);
/* 041 */     UTF8String value_1 = isNull_1 ?
/* 042 */     null : (i.getUTF8String(1));
/* 043 */     if (isNull_1) {
/* 044 */       mutableStateArray_0[0].setNullAt(1);
/* 045 */     } else {
/* 046 */       mutableStateArray_0[0].write(1, value_1);
/* 047 */     }
/* 048 */     return (mutableStateArray_0[0].getRow());
/* 049 */   }
/* 050 */
/* 051 */
/* 052 */ }

14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - Task 773 acquired 256.0 KB for org.apache.spark.unsafe.map.BytesToBytesMap@636fce52
14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - code for input[0, bigint, true]:
/* 001 */ public java.lang.Object generate(Object[] references) {
/* 002 */   return new SpecificUnsafeProjection(references);
/* 003 */ }
/* 004 */
/* 005 */ class SpecificUnsafeProjection extends org.apache.spark.sql.catalyst.expressions.UnsafeProjection {
/* 006 */
/* 007 */   private Object[] references;
/* 008 */   private org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[] mutableStateArray_0 = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter[1];
/* 009 */
/* 010 */   public SpecificUnsafeProjection(Object[] references) {
/* 011 */     this.references = references;
/* 012 */     mutableStateArray_0[0] = new org.apache.spark.sql.catalyst.expressions.codegen.UnsafeRowWriter(1, 0);
/* 013 */
/* 014 */   }
/* 015 */
/* 016 */   public void initialize(int partitionIndex) {
/* 017 */
/* 018 */   }
/* 019 */
/* 020 */   // Scala.Function1 need this
/* 021 */   public java.lang.Object apply(java.lang.Object row) {
/* 022 */     return apply((InternalRow) row);
/* 023 */   }
/* 024 */
/* 025 */   public UnsafeRow apply(InternalRow i) {
/* 026 */     mutableStateArray_0[0].reset();
/* 027 */
/* 028 */
/* 029 */     mutableStateArray_0[0].zeroOutNullBytes();
/* 030 */
/* 031 */     boolean isNull_0 = i.isNullAt(0);
/* 032 */     long value_0 = isNull_0 ?
/* 033 */     -1L : (i.getLong(0));
/* 034 */     if (isNull_0) {
/* 035 */       mutableStateArray_0[0].setNullAt(0);
/* 036 */     } else {
/* 037 */       mutableStateArray_0[0].write(0, value_0);
/* 038 */     }
/* 039 */     return (mutableStateArray_0[0].getRow());
/* 040 */   }
/* 041 */
/* 042 */
/* 043 */ }

14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - Task 773 acquired 32.0 MB for org.apache.spark.unsafe.map.BytesToBytesMap@636fce52
14 Jul 2022 14:05:18,867 Executor task launch worker for task 773 - Task 773 release 256.0 KB from org.apache.spark.unsafe.map.BytesToBytesMap@636fce52
